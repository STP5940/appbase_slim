"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const grpc_1 = require("grpc");
const sha3_1 = __importDefault(require("sha3"));
const admission_control_grpc_pb_1 = require("../__generated__/admission_control_grpc_pb");
const admission_control_grpc_web_pb_1 = require("../__generated__/admission_control_grpc_web_pb");
const admission_control_pb_1 = require("../__generated__/admission_control_pb");
const get_with_proof_pb_1 = require("../__generated__/get_with_proof_pb");
const transaction_pb_1 = require("../__generated__/transaction_pb");
const HashSaltValues_1 = __importDefault(require("../constants/HashSaltValues"));
const ServerHosts_1 = __importDefault(require("../constants/ServerHosts"));
const transaction_1 = require("../transaction");
const Accounts_1 = require("../wallet/Accounts");
const Decoder_1 = require("./Decoder");
const Encoder_1 = require("./Encoder");
var LibraNetwork;
(function (LibraNetwork) {
    LibraNetwork["Testnet"] = "testnet";
    // Mainnet = 'mainnet'
})(LibraNetwork = exports.LibraNetwork || (exports.LibraNetwork = {}));
class LibraClient {
    constructor(config) {
        this.config = config;
        if (config.host === undefined) {
            // since only testnet for now
            this.config.host = ServerHosts_1.default.DefaultTestnet;
        }
        if (config.port === undefined) {
            this.config.port = '80';
        }
        if (config.transferProtocol === undefined) {
            this.config.transferProtocol = 'http';
        }
        if (config.dataProtocol === undefined) {
            this.config.dataProtocol = 'grpc';
        }
        const connectionAddress = `${this.config.dataProtocol === 'grpc' ? '' : this.config.transferProtocol + '://'}${this.config.host}:${this.config.port}`;
        if (this.config.dataProtocol === 'grpc') {
            this.client = new admission_control_grpc_pb_1.AdmissionControlClient(connectionAddress, grpc_1.credentials.createInsecure());
        }
        else {
            this.client = new admission_control_grpc_web_pb_1.AdmissionControlClient(connectionAddress, null);
        }
        this.decoder = new Decoder_1.ClientDecoder();
        this.encoder = new Encoder_1.ClientEncoder(this);
    }
    /**
     * Fetch the current state of an account.
     *
     *
     * @param {string} address Accounts address
     */
    async getAccountState(address) {
        const result = await this.getAccountStates([address]);
        return result[0];
    }
    /**
     * Fetches the current state of multiple accounts.
     *
     * @param {AccountAddressLike[]} addresses Array of users addresses
     */
    async getAccountStates(addresses) {
        const accountAddresses = addresses.map(address => new Accounts_1.AccountAddress(address));
        const request = new get_with_proof_pb_1.UpdateToLatestLedgerRequest();
        accountAddresses.forEach(address => {
            const requestItem = new get_with_proof_pb_1.RequestItem();
            const getAccountStateRequest = new get_with_proof_pb_1.GetAccountStateRequest();
            getAccountStateRequest.setAddress(address.toBytes());
            requestItem.setGetAccountStateRequest(getAccountStateRequest);
            request.addRequestedItems(requestItem);
        });
        return new Promise((resolve, reject) => {
            const responseTask = (error, response) => {
                if (error) {
                    return reject(error);
                }
                resolve(response.getResponseItemsList().map((item, index) => {
                    const stateResponse = item.getGetAccountStateResponse();
                    const stateWithProof = stateResponse.getAccountStateWithProof();
                    if (stateWithProof.hasBlob()) {
                        const stateBlob = stateWithProof.getBlob();
                        const blob = stateBlob.getBlob_asU8();
                        return this.decoder.decodeAccountStateBlob(blob);
                    }
                    return Accounts_1.AccountState.default(accountAddresses[index].toHex());
                }));
            };
            if (this.client instanceof admission_control_grpc_web_pb_1.AdmissionControlClient) {
                this.client.updateToLatestLedger(request, undefined, responseTask);
            }
            else {
                this.client.updateToLatestLedger(request, responseTask);
            }
        });
    }
    /**
     * Returns the Accounts transaction done with sequenceNumber.
     *
     */
    async getAccountTransaction(address, sequenceNumber, fetchEvents = true) {
        const accountAddress = new Accounts_1.AccountAddress(address);
        const parsedSequenceNumber = new bignumber_js_1.default(sequenceNumber);
        const request = new get_with_proof_pb_1.UpdateToLatestLedgerRequest();
        const requestItem = new get_with_proof_pb_1.RequestItem();
        const getTransactionRequest = new get_with_proof_pb_1.GetAccountTransactionBySequenceNumberRequest();
        getTransactionRequest.setAccount(accountAddress.toBytes());
        getTransactionRequest.setSequenceNumber(parsedSequenceNumber.toNumber());
        getTransactionRequest.setFetchEvents(fetchEvents);
        requestItem.setGetAccountTransactionBySequenceNumberRequest(getTransactionRequest);
        request.addRequestedItems(requestItem);
        return new Promise((resolve, reject) => {
            const responseTask = (error, response) => {
                if (error) {
                    return reject(error);
                }
                const responseItems = response.getResponseItemsList();
                if (responseItems.length === 0) {
                    return resolve(null);
                }
                const r = responseItems[0].getGetAccountTransactionBySequenceNumberResponse();
                const signedTransactionWP = r.getSignedTransactionWithProof();
                resolve(this.decoder.decodeSignedTransactionWithProof(signedTransactionWP));
            };
            if (this.client instanceof admission_control_grpc_web_pb_1.AdmissionControlClient) {
                this.client.updateToLatestLedger(request, undefined, responseTask);
            }
            else {
                this.client.updateToLatestLedger(request, responseTask);
            }
        });
    }
    /**
     * Uses the faucetService on testnet to mint coins to be sent
     * to receiver.
     *
     * Returns the sequence number for the transaction used to mint
     *
     * Note: `numCoins` should be in base unit i.e microlibra (10^6 I believe).
     */
    async mintWithFaucetService(receiver, numCoins, waitForConfirmation = true) {
        const serverHost = this.config.faucetServerHost || ServerHosts_1.default.DefaultFaucet;
        const coins = new bignumber_js_1.default(numCoins).toString(10);
        const address = receiver.toString();
        const response = await axios_1.default.get(`http://${serverHost}?amount=${coins}&address=${address}`);
        if (response.status !== 200) {
            throw new Error(`Failed to query faucet service. Code: ${response.status}, Err: ${response.data.toString()}`);
        }
        const sequenceNumber = response.data;
        if (waitForConfirmation) {
            await this.waitForConfirmation(Accounts_1.AccountAddress.default(), sequenceNumber);
        }
        return sequenceNumber;
    }
    /**
     * Keeps polling the account state of address till sequenceNumber is computed.
     *
     */
    async waitForConfirmation(accountAddress, transactionSequenceNumber) {
        const sequenceNumber = new bignumber_js_1.default(transactionSequenceNumber);
        const address = accountAddress.toString();
        let maxIterations = 50;
        const poll = (resolve, reject) => {
            setTimeout(() => {
                maxIterations--;
                this.getAccountState(address)
                    .then(accountState => {
                    if (accountState.sequenceNumber.gte(sequenceNumber)) {
                        return resolve();
                    }
                    if (maxIterations === -1) {
                        reject(new Error(`Confirmation timeout for [${address}]:[${sequenceNumber.toString(10)}]`));
                    }
                    else {
                        poll(resolve, reject);
                    }
                })
                    .catch(reject);
            }, 1000);
        };
        return new Promise((resolve, reject) => {
            poll(resolve, reject);
        });
    }
    /**
     * Sign the transaction with keyPair and returns a promise that resolves to a LibraSignedTransaction
     *
     *
     */
    async signTransaction(transaction, keyPair) {
        const rawTxn = await this.encoder.encodeLibraTransaction(transaction, transaction.sendersAddress);
        const signature = this.signRawTransaction(rawTxn, keyPair);
        return new transaction_1.LibraSignedTransaction(transaction, keyPair.getPublicKey(), signature);
    }
    /**
     * Transfer coins from sender to receipient.
     * numCoins should be in libraCoins based unit.
     *
     */
    async transferCoins(sender, recipientAddress, numCoins) {
        return this.execute(transaction_1.LibraTransaction.createTransfer(recipientAddress, new bignumber_js_1.default(numCoins)), sender);
    }
    /**
     * Execute a transaction by sender.
     *
     */
    async execute(transaction, sender) {
        const rawTransaction = await this.encoder.encodeLibraTransaction(transaction, sender.getAddress());
        const signedTransaction = new transaction_pb_1.SignedTransaction();
        const request = new admission_control_pb_1.SubmitTransactionRequest();
        const senderSignature = this.signRawTransaction(rawTransaction, sender.keyPair);
        signedTransaction.setRawTxnBytes(rawTransaction.serializeBinary());
        signedTransaction.setSenderPublicKey(sender.keyPair.getPublicKey());
        signedTransaction.setSenderSignature(senderSignature);
        request.setSignedTxn(signedTransaction);
        return new Promise((resolve, reject) => {
            const responseTask = (error, response) => {
                if (error) {
                    // TBD: should this fail with only service error
                    // or should it fail if transaction is not acknowledged
                    return reject(error);
                }
                const vmStatus = this.decoder.decodeVMStatus(response.getVmStatus());
                resolve(new transaction_1.LibraTransactionResponse(new transaction_1.LibraSignedTransaction(transaction, sender.keyPair.getPublicKey(), senderSignature), response.getValidatorId_asU8(), response.hasAcStatus()
                    ? response.getAcStatus().getCode() : transaction_1.LibraAdmissionControlStatus.UNKNOWN, response.hasMempoolStatus()
                    ? response.getMempoolStatus().getCode() : transaction_1.LibraMempoolTransactionStatus.UNKNOWN, vmStatus));
            };
            if (this.client instanceof admission_control_grpc_web_pb_1.AdmissionControlClient) {
                this.client.submitTransaction(request, undefined, responseTask);
            }
            else {
                this.client.submitTransaction(request, responseTask);
            }
        });
    }
    signRawTransaction(rawTransaction, keyPair) {
        const rawTxnBytes = rawTransaction.serializeBinary();
        const hash = new sha3_1.default(256)
            .update(Buffer.from(HashSaltValues_1.default.rawTransactionHashSalt, 'hex'))
            .update(Buffer.from(rawTxnBytes.buffer))
            .digest();
        return keyPair.sign(hash);
    }
}
exports.LibraClient = LibraClient;
exports.default = LibraClient;
