"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const transaction_pb_1 = require("../__generated__/transaction_pb");
/**
 * Internal class used by LibraClient
 * to encode Libra* classes exposed by library into pb classes used with rbc
 */
class ClientEncoder {
    constructor(client) {
        this.client = client;
    }
    async encodeLibraTransaction(transaction, senderAccountAddress) {
        let senderAddress = transaction.sendersAddress;
        if (senderAddress.isDefault()) {
            senderAddress = senderAccountAddress;
        }
        let sequenceNumber = transaction.sequenceNumber;
        if (sequenceNumber.isNegative()) {
            const senderAccountState = await this.client.getAccountState(senderAddress.toHex());
            sequenceNumber = senderAccountState.sequenceNumber;
        }
        const program = new transaction_pb_1.Program();
        program.setCode(transaction.program.code);
        const transactionArguments = new Array();
        transaction.program.arguments.forEach(argument => {
            const transactionArgument = new transaction_pb_1.TransactionArgument();
            transactionArgument.setType(argument.type);
            transactionArgument.setData(argument.value);
            transactionArguments.push(transactionArgument);
        });
        program.setArgumentsList(transactionArguments);
        program.setModulesList(transaction.program.modules);
        const rawTransaction = new transaction_pb_1.RawTransaction();
        rawTransaction.setExpirationTime(transaction.expirationTime.toNumber());
        rawTransaction.setGasUnitPrice(transaction.gasContraint.gasUnitPrice.toNumber());
        rawTransaction.setMaxGasAmount(transaction.gasContraint.maxGasAmount.toNumber());
        rawTransaction.setSequenceNumber(sequenceNumber.toNumber());
        rawTransaction.setProgram(program);
        rawTransaction.setSenderAccount(senderAddress.toBytes());
        return rawTransaction;
    }
}
exports.ClientEncoder = ClientEncoder;
