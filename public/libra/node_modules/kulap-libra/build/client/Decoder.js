"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const transaction_pb_1 = require("../__generated__/transaction_pb");
const CursorBuffer_1 = require("../common/CursorBuffer");
const PathValues_1 = __importDefault(require("../constants/PathValues"));
const __1 = require("..");
const Accounts_1 = require("../wallet/Accounts");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const jspb = __importStar(require("google-protobuf"));
/**
 * Internal class used by LibraClient
 * to decode pb generated classes to Libra* Classes export by this library
 *
 */
class ClientDecoder {
    decodeAccountStateBlob(blob) {
        const cursor = new CursorBuffer_1.CursorBuffer(blob);
        const blobLen = cursor.read32();
        const state = {};
        for (let i = 0; i < blobLen; i++) {
            const keyLen = cursor.read32();
            const keyBuffer = new Uint8Array(keyLen);
            for (let j = 0; j < keyLen; j++) {
                keyBuffer[j] = cursor.read8();
            }
            const valueLen = cursor.read32();
            const valueBuffer = new Uint8Array(valueLen);
            for (let k = 0; k < valueLen; k++) {
                valueBuffer[k] = cursor.read8();
            }
            state[Buffer.from(keyBuffer).toString('hex')] = valueBuffer;
        }
        return Accounts_1.AccountState.fromBytes(state[PathValues_1.default.AccountStatePath]);
    }
    decodeSignedTransactionWithProof(signedTransactionWP) {
        // decode transaction
        const signedTransaction = signedTransactionWP.getSignedTransaction();
        const libraTransaction = this.decodeRawTransactionBytes(signedTransaction.getRawTxnBytes_asU8());
        const libraSignedtransaction = new __1.LibraSignedTransaction(libraTransaction, signedTransaction.getSenderPublicKey_asU8(), signedTransaction.getSenderSignature_asU8());
        // decode event
        let eventsList;
        if (signedTransactionWP.hasEvents()) {
            const events = signedTransactionWP.getEvents();
            eventsList = events.getEventsList().map(event => {
                let address;
                let path;
                if (event.hasAccessPath()) {
                    const accessPath = event.getAccessPath();
                    address = new Accounts_1.AccountAddress(accessPath.getAddress_asU8());
                    path = accessPath.getPath_asU8();
                }
                return new __1.LibraTransactionEvent(event.getEventData_asU8(), new bignumber_js_1.default(event.getSequenceNumber()), address, path);
            });
        }
        return new __1.LibraSignedTransactionWithProof(libraSignedtransaction, signedTransactionWP.getProof(), eventsList);
    }
    decodeRawTransactionBytes(rawTxnBytes) {
        const rawTxn = transaction_pb_1.RawTransaction.deserializeBinary(rawTxnBytes);
        const rawProgram = rawTxn.getProgram();
        const program = {
            arguments: rawProgram.getArgumentsList().map(argument => ({
                type: argument.getType(),
                value: argument.getData_asU8(),
            })),
            code: rawProgram.getCode_asU8(),
            modules: rawProgram.getModulesList(),
        };
        const gasContraint = {
            gasUnitPrice: new bignumber_js_1.default(rawTxn.getGasUnitPrice()),
            maxGasAmount: new bignumber_js_1.default(rawTxn.getMaxGasAmount()),
        };
        return new __1.LibraTransaction(program, gasContraint, new bignumber_js_1.default(rawTxn.getExpirationTime()), rawTxn.getSenderAccount_asU8(), new bignumber_js_1.default(rawTxn.getSequenceNumber()));
    }
    hasInvariantViolation(vmStatus) {
        return jspb.Message.getField(vmStatus, 3) != null;
    }
    hasDeserialization(vmStatus) {
        return jspb.Message.getField(vmStatus, 4) != null;
    }
    decodeVMStatus(vmStatus) {
        if (vmStatus === undefined) {
            return undefined;
        }
        let validationStatus;
        let verificationStatusErrors;
        let invariantViolationError;
        let deserializationError;
        let executionError;
        if (vmStatus.hasValidation()) {
            const validation = vmStatus.getValidation();
            validationStatus = {
                code: validation.getCode(),
                message: validation.getMessage(),
            };
        }
        if (vmStatus.hasVerification()) {
            const verification = vmStatus.getVerification();
            verificationStatusErrors = verification.getStatusListList().map(status => {
                return new __1.LibraVerificationStatusError(status.getErrorKind(), status.getModuleIdx(), status.getErrorKind(), status.getMessage());
            });
        }
        if (this.hasInvariantViolation(vmStatus)) {
            const invariant = vmStatus.getInvariantViolation();
            invariantViolationError = invariant;
        }
        if (this.hasDeserialization(vmStatus)) {
            const deser = vmStatus.getDeserialization();
            deserializationError = deser;
        }
        if (vmStatus.hasExecution()) {
            const execution = vmStatus.getExecution();
            executionError = {
                errorType: execution.getExecutionStatusCase(),
            };
        }
        return new __1.LibraVMStatusError(vmStatus.getErrorTypeCase(), validationStatus, verificationStatusErrors, invariantViolationError, deserializationError, executionError);
    }
}
exports.ClientDecoder = ClientDecoder;
