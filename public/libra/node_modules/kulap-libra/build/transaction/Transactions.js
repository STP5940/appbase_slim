"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const Addresses_1 = __importDefault(require("../constants/Addresses"));
const ProgamBase64Codes_1 = __importDefault(require("../constants/ProgamBase64Codes"));
const Accounts_1 = require("../wallet/Accounts");
var LibraProgramArgumentType;
(function (LibraProgramArgumentType) {
    LibraProgramArgumentType[LibraProgramArgumentType["U64"] = 0] = "U64";
    LibraProgramArgumentType[LibraProgramArgumentType["ADDRESS"] = 1] = "ADDRESS";
    LibraProgramArgumentType[LibraProgramArgumentType["STRING"] = 2] = "STRING";
    LibraProgramArgumentType[LibraProgramArgumentType["BYTEARRAY"] = 3] = "BYTEARRAY";
})(LibraProgramArgumentType = exports.LibraProgramArgumentType || (exports.LibraProgramArgumentType = {}));
class LibraTransaction {
    static createTransfer(recipientAddress, numAccount) {
        const amountBuffer = Buffer.from(Number(numAccount)
            .toString(16)
            .padStart(16, '0')
            .slice(0, 16), 'hex');
        amountBuffer.reverse();
        const programArguments = [
            {
                type: LibraProgramArgumentType.ADDRESS,
                value: Uint8Array.from(Buffer.from(recipientAddress, 'hex')),
            },
            {
                type: LibraProgramArgumentType.U64,
                value: Uint8Array.from(amountBuffer),
            },
        ];
        const program = {
            arguments: programArguments,
            code: Uint8Array.from(Buffer.from(ProgamBase64Codes_1.default.peerToPeerTxn, 'base64')),
            modules: [],
        };
        return new LibraTransaction(program, {
            gasUnitPrice: new bignumber_js_1.default(0),
            maxGasAmount: new bignumber_js_1.default(1000000),
        }, `${Math.floor(new Date().getTime() / 1000) + 100}`, new Uint8Array(Addresses_1.default.AddressLength), '-1');
    }
    /**
     * Create a new Transaction
     *
     * @param program
     * @param gasConstraint
     * @param expirationTime
     * @param sendersAddress
     * @param sequenceNumber
     */
    constructor(program, gasConstraint, expirationTime, sendersAddress, sequenceNumber) {
        this.program = program;
        this.gasContraint = gasConstraint;
        this.expirationTime = new bignumber_js_1.default(expirationTime);
        this.sendersAddress = new Accounts_1.AccountAddress(sendersAddress);
        this.sequenceNumber = new bignumber_js_1.default(sequenceNumber);
    }
}
exports.LibraTransaction = LibraTransaction;
class LibraTransactionResponse {
    constructor(signedTransaction, validatorId, acStatus, mempoolStatus, vmStatus) {
        this.signedTransaction = signedTransaction;
        this.validatorId = validatorId;
        this.acStatus = acStatus;
        this.mempoolStatus = mempoolStatus;
        this.vmStatus = vmStatus;
    }
    async awaitConfirmation(client) {
        return client.waitForConfirmation(this.signedTransaction.transaction.sendersAddress, this.signedTransaction.transaction.sequenceNumber.plus(1));
    }
}
exports.LibraTransactionResponse = LibraTransactionResponse;
var LibraAdmissionControlStatus;
(function (LibraAdmissionControlStatus) {
    LibraAdmissionControlStatus[LibraAdmissionControlStatus["ACCEPTED"] = 0] = "ACCEPTED";
    LibraAdmissionControlStatus[LibraAdmissionControlStatus["BLACKLISTED"] = 1] = "BLACKLISTED";
    LibraAdmissionControlStatus[LibraAdmissionControlStatus["REJECTED"] = 2] = "REJECTED";
    LibraAdmissionControlStatus[LibraAdmissionControlStatus["UNKNOWN"] = -1] = "UNKNOWN";
})(LibraAdmissionControlStatus = exports.LibraAdmissionControlStatus || (exports.LibraAdmissionControlStatus = {}));
var LibraMempoolTransactionStatus;
(function (LibraMempoolTransactionStatus) {
    LibraMempoolTransactionStatus[LibraMempoolTransactionStatus["VALID"] = 0] = "VALID";
    LibraMempoolTransactionStatus[LibraMempoolTransactionStatus["INSUFFICIENTBALANCE"] = 1] = "INSUFFICIENTBALANCE";
    LibraMempoolTransactionStatus[LibraMempoolTransactionStatus["INVALIDSEQNUMBER"] = 2] = "INVALIDSEQNUMBER";
    LibraMempoolTransactionStatus[LibraMempoolTransactionStatus["MEMPOOLISFULL"] = 3] = "MEMPOOLISFULL";
    LibraMempoolTransactionStatus[LibraMempoolTransactionStatus["TOOMANYTRANSACTIONS"] = 4] = "TOOMANYTRANSACTIONS";
    LibraMempoolTransactionStatus[LibraMempoolTransactionStatus["INVALIDUPDATE"] = 5] = "INVALIDUPDATE";
    LibraMempoolTransactionStatus[LibraMempoolTransactionStatus["UNKNOWN"] = -1] = "UNKNOWN";
})(LibraMempoolTransactionStatus = exports.LibraMempoolTransactionStatus || (exports.LibraMempoolTransactionStatus = {}));
class LibraSignedTransaction {
    constructor(transaction, publicKey, signature) {
        this.transaction = transaction;
        this.publicKey = publicKey;
        this.signature = signature;
    }
}
exports.LibraSignedTransaction = LibraSignedTransaction;
class LibraSignedTransactionWithProof {
    constructor(signedTransaction, proof, events) {
        this.signedTransaction = signedTransaction;
        this.proof = proof;
        this.events = events;
    }
}
exports.LibraSignedTransactionWithProof = LibraSignedTransactionWithProof;
// TODO: Implement abstraction over the pb classes for transaction proof
class LibraSignedTransactionProof {
}
class LibraTransactionEvent {
    constructor(data, sequenceNumber, address, path) {
        this.data = data;
        this.sequenceNumber = new bignumber_js_1.default(sequenceNumber);
        this.address = address;
        this.path = path;
    }
}
exports.LibraTransactionEvent = LibraTransactionEvent;
